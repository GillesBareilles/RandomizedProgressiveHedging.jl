<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · RPH</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RPH</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Getting-solvers-1">Getting solvers</a></li><li><a class="toctext" href="#Laying-out-a-problem-1">Laying out a problem</a></li><li><a class="toctext" href="#Solving-a-problem-1">Solving a problem</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../public_api/">Public</a></li><li><a class="toctext" href="../internal_api/">Internal</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/yassine-laguel/RPH.jl/blob/master/docs/src/quickstart.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Quick-start-guide-1" href="#Quick-start-guide-1">Quick start guide</a></h1><p>This section aims provides an explanation of how to build and solve a problem using RPH.jl by solving a toy problem. The equivalent script and ijulia notebook can be found in the <code>example</code> folder.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>RPH.jl is a pure julia package. It can be installed from julia by using the built-in package manager:</p><pre><code class="language-julia">using Pkg
Pkg.add(&quot;https://github.com/yassine-laguel/RPH.jl&quot;)</code></pre><h2><a class="nav-anchor" id="Getting-solvers-1" href="#Getting-solvers-1">Getting solvers</a></h2><p>RPH depends on other solvers to optimize the subproblems. All solvers interfaced with JuMP, the julia mathematical programming language, can be used in RPH, a list of which can be found at <a href="http://www.juliaopt.org/JuMP.jl/v0.19.0/installation/#Getting-Solvers-1">JuMP&#39;s documentation</a>.</p><p>Note that all algorithms layout subproblem with quadratic objectives. Default subproblem solver is the interior point algorithm Ipopt.</p><h2><a class="nav-anchor" id="Laying-out-a-problem-1" href="#Laying-out-a-problem-1">Laying out a problem</a></h2><p>We take the following problem as example:</p><div>\[\begin{aligned}
\underset{x}{\text{minimize}}\quad
&amp; \sum_{t=1}^T C e_t + y_t \\
\text{s.t.}\quad
&amp; q_t, y_t, e_t \ge 0 \\
&amp; q_t \le W \\
&amp; e_t+y_t \ge D \\
&amp; q_1 = \bar{r}-y_1 \\
&amp; q_t = q_{t-1}+r[\xi_t]-y_t, \; t = 2, \ldots, T.
\end{aligned}\]</div><p>where <span>$C = 5$</span>, <span>$W = 8$</span>, <span>$D = 6$</span>, <span>$r = [2, 10]$</span>. A scenario is defined by <span>$(\xi_t)_{t=2, \ldots, T}$</span>, for <span>$\xi_t\in\{1,2\}$</span>.</p><h3><a class="nav-anchor" id="Representing-a-scenario-1" href="#Representing-a-scenario-1">Representing a scenario</a></h3><p>A scenario is represented by the following structure:</p><pre><code class="language-julia">struct HydroThermalScenario &lt;: AbstractScenario
    weather::Vector{Int}
end</code></pre><p>Here, the attribut <code>weather</code> will hold one realisation of <span>$(\xi_t)_{t=2, \ldots, T}$</span>.</p><p>Along with this scenario structure, the function laying out the scenario objective function <span>$f_s$</span> needs to be defined. It takes as input the JuMP model that will hold <span>$f_s$</span>, an instance of the previously defined scenario structure, and the identifier of the scenario.</p><pre><code class="language-julia">function build_fs!(model::JuMP.Model, s::HydroThermalScenario, id_scen::ScenarioId)
    C = 5
    W = 8
    D = 6
    rain = [2, 10]

    T = length(s.weather)+1
    Y = @variable(model, [1:3*T], base_name=&quot;y_s$id_scen&quot;)

    q = [Y[1+3*k] for k in 0:T-1]
    y = [Y[2+3*k] for k in 0:T-1]
    e = [Y[3+3*k] for k in 0:T-1]

    ## State variables constraints
    @constraint(model, Y[:] .&gt;= 0)      # positivity constraint
    @constraint(model, q .&lt;= W)         # reservoir max capacity
    @constraint(model, e .+ y .&gt;= D)    # meet demand
    
    ## Dynamic constraints
    @constraint(model, q[1] == sum(rain)/length(rain) - y[1])
    @constraint(model, [t=2:T], q[t] == q[t-1] - y[t] + rain[s.weather[t-1]+1])
    
    objexpr = C*sum(e) + sum(y)

    return Y, objexpr, []
end</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ul><li>The last item returned by the function should be the reference of constraints used to build the objective, none here. Such constraints can appear when modelling a <span>$\max(u, v)$</span> in the objective as a variable <span>$m$</span>, under the linear constraints <span>$m\ge u$</span> and <span>$m\ge v$</span>.</li></ul></div></div><h3><a class="nav-anchor" id="Representing-the-scenario-tree-1" href="#Representing-the-scenario-tree-1">Representing the scenario tree</a></h3><p>The scenario tree represents the stage up to which scenarios are equal.</p><p>If the problem scenario tree is a <a href="https://en.wikipedia.org/wiki/M-ary_tree#Types_of_m-ary_trees">perfect <em>m</em>-ary tree</a>, it can be built using a buit-in function:</p><pre><code class="language-julia">scenariotree = ScenarioTree(; depth=T, nbranching=2)</code></pre><p>If the tree is not regular, or quite simple, it can be built by writing specifically the partition of equivalent scenarios per stage. A simple exmaple would be:</p><pre><code class="language-julia">stageid_to_scenpart = [
    OrderedSet([BitSet(1:3)]),                      # Stage 1
    OrderedSet([BitSet(1), BitSet(2:3)]),           # Stage 2
    OrderedSet([BitSet(1), BitSet(2), BitSet(3)]),  # Stage 3
]</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>However this method is not efficient, and whenever possible, builtin functions should be priviledged.</p></div></div><h3><a class="nav-anchor" id="Building-the-Problem-1" href="#Building-the-Problem-1">Building the <code>Problem</code></a></h3><pre><code class="language-julia">scenid_to_weather(scen_id, T) = return [mod(floor(Int, scen_id / 2^i), 2) for i in T-1:-1:0]

T = 5
nbranching = 2

p = 0.5

nscenarios = 2^(T-1)
scenarios = HydroThermalScenario[ HydroThermalScenario( scenid_to_weather(scen_id, T-1) ) for scen_id in 0:nscenarios-1]
probas = [ prod(v*p + (1-v)*(1-p) for v in scenid_to_weather(scen_id, T-1)) for scen_id in 1:nscenarios ]

stage_to_dim = [3*i-2:3*i for i in 1:T]
scenariotree = ScenarioTree(; depth=T, nbranching=2)


pb = Problem(
    scenarios::Vector{HydroThermalScenario},
    build_fs!::Function,
    probas::Vector{Float64},
    nscenarios::Int,
    T::Int,
    stage_to_dim::Vector{UnitRange{Int}},
    scenariotree::ScenarioTree,
)</code></pre><h2><a class="nav-anchor" id="Solving-a-problem-1" href="#Solving-a-problem-1">Solving a problem</a></h2><h3><a class="nav-anchor" id="Explicitly-solving-the-problem-1" href="#Explicitly-solving-the-problem-1">Explicitly solving the problem</a></h3><pre><code class="language-julia">y_direct = solve_direct(pb)
println(&quot;\nDirect solve output is:&quot;)
display(y_direct)
@show objective_value(pb, y_direct)</code></pre><h3><a class="nav-anchor" id="Solving-with-Progressive-Hedging-1" href="#Solving-with-Progressive-Hedging-1">Solving with Progressive Hedging</a></h3><pre><code class="language-julia">y_PH = solve_progressivehedging(pb, ϵ_primal=1e-4, ϵ_dual=1e-4, printstep=5)
println(&quot;\nSequential solve output is:&quot;)
display(y_PH)
@show objective_value(pb, y_PH)</code></pre><h3><a class="nav-anchor" id="Solving-with-Randomized-Progressive-Hedging-1" href="#Solving-with-Randomized-Progressive-Hedging-1">Solving with Randomized Progressive Hedging</a></h3><pre><code class="language-julia">y_sync = solve_randomized_sync(pb, maxtime=5, printstep=50)
println(&quot;\nSynchronous solve output is:&quot;)
display(y_sync)
@show objective_value(pb, y_sync)</code></pre><h3><a class="nav-anchor" id="Solving-with-Parallel-Randomized-Progressive-Hedging-1" href="#Solving-with-Parallel-Randomized-Progressive-Hedging-1">Solving with Parallel Randomized Progressive Hedging</a></h3><pre><code class="language-julia">y_par = solve_randomized_par(pb, maxtime=5, printstep=50)
println(&quot;\nSynchronous solve output is:&quot;)
display(y_par)
@show objective_value(pb, y_par)</code></pre><h3><a class="nav-anchor" id="Solving-with-Asynchronous-Randomized-Progressive-Hedging-1" href="#Solving-with-Asynchronous-Randomized-Progressive-Hedging-1">Solving with Asynchronous Randomized Progressive Hedging</a></h3><p>Asynchronous solve leverages the distributed capacities of julia. In order to be used, workers need to be available. Local or remote workers can be added with <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/#Distributed.addprocs"><code>addprocs</code></a>.</p><p><code>RPH</code> and <code>JuMP</code> packages need to be available for all workers, along with the scenario object and objective build function.</p><pre><code class="language-julia">addprocs(3)     # add 3 workers besides master
@everywhere using RPH, JuMP

@everywhere HydroThermalScenario, build_fs!

y_async = solve_randomized_async(pb, maxtime=5, printstep=100)
println(&quot;Asynchronous solve output is:&quot;)
display(y_async)
@show objective_value(pb, y_par)</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../public_api/"><span class="direction">Next</span><span class="title">Public</span></a></footer></article></body></html>
