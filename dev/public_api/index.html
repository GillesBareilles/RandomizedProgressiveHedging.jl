<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · RPH</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RPH</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../quickstart/">Tutorial</a></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href>Public</a><ul class="internal"><li><a class="toctext" href="#Building-a-problem-1">Building a problem</a></li><li><a class="toctext" href="#Solving-a-problem-1">Solving a problem</a></li><li><a class="toctext" href="#Other-1">Other</a></li></ul></li><li><a class="toctext" href="../internal_api/">Internal</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Public</a></li></ul><a class="edit-page" href="https://github.com/yassine-laguel/RPH.jl/blob/master/docs/src/public_api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Public</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Public-reference-1" href="#Public-reference-1">Public reference</a></h1><h2><a class="nav-anchor" id="Building-a-problem-1" href="#Building-a-problem-1">Building a problem</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RPH.AbstractScenario" href="#RPH.AbstractScenario"><code>RPH.AbstractScenario</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractScenario</code></pre><p>Abstract type that user scenario concrete types should descend from.</p><p><strong>Example</strong></p><pre><code class="language-julia">struct MyScenario &lt;: AbstractScenario
    value::Vector{Float64}
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/yassine-laguel/RPH.jl/blob/038e6096a58fcd9beb0d08cf22d5f83c2512c436/src/RPH.jl#L19-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RPH.build_fs!" href="#RPH.build_fs!"><code>RPH.build_fs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">build_fs!(model::JuMP.Model, s::S, id_scen::ScenarioId) where S&lt;:AbstractScenario</code></pre><p>Define variables, build the objective function, build and attach constraints relative  to the scenario <code>s</code>, of identifier <code>id_scen</code>, into the given JuMP <code>model</code>.</p><p>Return value: a tuple of</p><ul><li>array of subproblem variables</li><li>expression of objective function</li><li>array of references to constraints that define the objective, as opposed to constraints that define the feasible space.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">function build_fs!(model::JuMP.Model, s::MyScenario, id_scen::ScenarioId)
    nstages = length(s.value)

    Y = @variable(model, [1:nstages], base_name=&quot;y_s$id_scen&quot;)
    m = @variable(model)

    # feasibility constraints
    @constraint(model, Y[:] .&gt;= 0)

    # objective constraints, enforcing m=maximum(Y)
    max_ctrs = @constraint(model, [i in 1:stages], m .&gt;= Y[i])
    
    objexpr = sum( (Y[i]-s.value[i])^2 for i in 1:nstages) + m

    return Y, objexpr, max_ctrs
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/yassine-laguel/RPH.jl/blob/038e6096a58fcd9beb0d08cf22d5f83c2512c436/src/RPH.jl#L35-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RPH.ScenarioTree" href="#RPH.ScenarioTree"><code>RPH.ScenarioTree</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ScenarioTree</code></pre><p>A tree structure to hold the <em>non-anticipativity</em> structure of a <a href="#RPH.Problem"><code>Problem</code></a>.</p><p>All nodes are stored in the <code>vecnodes</code> vector, and referenced by their index.</p><p><strong>Note</strong>: The tree nodes should be indexed in such a way that all sets of equivalent scenarios be made of adjacent indices (<code>n1:n2</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/yassine-laguel/RPH.jl/blob/038e6096a58fcd9beb0d08cf22d5f83c2512c436/src/RPH.jl#L90-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RPH.Problem" href="#RPH.Problem"><code>RPH.Problem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Problem{T}</code></pre><p>TODO</p></div></div><a class="source-link" target="_blank" href="https://github.com/yassine-laguel/RPH.jl/blob/038e6096a58fcd9beb0d08cf22d5f83c2512c436/src/RPH.jl#L113-L117">source</a></section><h2><a class="nav-anchor" id="Solving-a-problem-1" href="#Solving-a-problem-1">Solving a problem</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RPH.solve_direct-Tuple{Problem}" href="#RPH.solve_direct-Tuple{Problem}"><code>RPH.solve_direct</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">x = solve_direct(pb::Problem; optimizer = GLPK.Optimizer, printlev=1)</code></pre><p>Build the progressive hedging problem by explicitly laying out non-anticipatory  constraints, and solve globally.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>optimizer</code>: optimizer used for solve. Default is <code>GLPK.Optimizer</code>.</li><li><code>optimizer_params</code>: a <code>Dict{Symbol, Any}</code> storing parameters for the optimizer.</li><li><code>printlev</code>: if 0, mutes output from the function (not solver). Default value is 1.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/yassine-laguel/RPH.jl/blob/038e6096a58fcd9beb0d08cf22d5f83c2512c436/src/solve_direct.jl#L21-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RPH.solve_progressivehedging-Tuple{Problem}" href="#RPH.solve_progressivehedging-Tuple{Problem}"><code>RPH.solve_progressivehedging</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">x = solve_progressivehedging(pb::Problem)</code></pre><p>Run the classical Progressive Hedging scheme on problem <code>pb</code>. </p><p>Stopping criterion is based on primal dual residual, maximum iterations or time  can also be set. Return a feasible point <code>x</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>ϵ_primal</code>: Tolerance on primal residual.</li><li><code>ϵ_dual</code>: Tolerance on dual residual.</li><li><code>μ</code>: Regularization parameter.</li><li><code>maxtime</code>: Limit time spent in computations.</li><li><code>maxiter</code>: Maximum iterations.</li><li><code>printlev</code>: if 0, mutes output.</li><li><code>printstep</code>: number of iterations skipped between each print and logging.</li><li><code>hist</code>: if not nothing, will record:<ul><li><code>:functionalvalue</code>: array of functional value indexed by iteration,</li><li><code>:time</code>: array of time at the end of each iteration, indexed by iteration,</li><li><code>:dist_opt</code>: if dict has entry <code>:approxsol</code>, array of distance between iterate and <code>hist[:approxsol]</code>, indexed by iteration.</li><li><code>:logstep</code>: number of iteration between each log.</li></ul></li><li><code>optimizer</code>: an optimizer for subproblem solve.</li><li><code>optimizer_params</code>: a <code>Dict{Symbol, Any}</code> storing parameters for the optimizer.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/yassine-laguel/RPH.jl/blob/038e6096a58fcd9beb0d08cf22d5f83c2512c436/src/solve_progressiveheding.jl#L30-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RPH.solve_randomized_sync-Tuple{Problem}" href="#RPH.solve_randomized_sync-Tuple{Problem}"><code>RPH.solve_randomized_sync</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">solve_randomized_sync(pb::Problem)</code></pre><p>Run the Randomized Progressive Hedging scheme on problem <code>pb</code>.</p><p>Stopping criterion is maximum iterations or time. Return a feasible point <code>x</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>μ</code>: Regularization parameter.</li><li><code>qdistr</code>: if not nothing, specifies the probablility distribution for scenario sampling.</li><li><code>maxtime</code>: Limit time spent in computations.</li><li><code>maxiter</code>: Maximum iterations.</li><li><code>printlev</code>: if 0, mutes output.</li><li><code>printstep</code>: number of iterations skipped between each print and logging.</li><li><code>seed</code>: if not nothing, specifies the seed used for scenario sampling.</li><li><code>hist</code>: if not nothing, will record:<ul><li><code>:functionalvalue</code>: array of functional value indexed by iteration,</li><li><code>:time</code>: array of time at the end of each iteration, indexed by iteration,</li><li><code>:dist_opt</code>: if dict has entry <code>:approxsol</code>, array of distance between iterate and <code>hist[:approxsol]</code>, indexed by iteration.</li><li><code>:logstep</code>: number of iteration between each log.</li></ul></li><li><code>optimizer</code>: an optimizer for subproblem solve.</li><li><code>optimizer_params</code>: a <code>Dict{Symbol, Any}</code> storing parameters for the optimizer.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/yassine-laguel/RPH.jl/blob/038e6096a58fcd9beb0d08cf22d5f83c2512c436/src/solve_randomized_sync.jl#L46-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RPH.solve_randomized_async-Union{Tuple{Problem{T}}, Tuple{T}} where T&lt;:AbstractScenario" href="#RPH.solve_randomized_async-Union{Tuple{Problem{T}}, Tuple{T}} where T&lt;:AbstractScenario"><code>RPH.solve_randomized_async</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">solve_randomized_async(pb::Problem{T}) where T&lt;:AbstractScenario</code></pre><p>Run the Randomized Progressive Hedging scheme on problem <code>pb</code>. All workers should be available.</p><p>Stopping criterion is maximum iterations or time. Return a feasible point <code>x</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>μ</code>: Regularization parameter.</li><li><code>c</code>: parameter for step length.</li><li><code>stepsize</code>: if nothing uses theoretical formula for stepsize, otherwise uses constant numerical value.</li><li><code>qdistr</code>: if not nothing, specifies the probablility distribution for scenario sampling.</li><li><code>maxtime</code>: Limit time spent in computations.</li><li><code>maxiter</code>: Maximum iterations.</li><li><code>printlev</code>: if 0, mutes output.</li><li><code>printstep</code>: number of iterations skipped between each print and logging.</li><li><code>seed</code>: if not nothing, specifies the seed used for scenario sampling.</li><li><code>hist</code>: if not nothing, will record:<ul><li><code>:functionalvalue</code>: array of functional value indexed by iteration,</li><li><code>:time</code>: array of time at the end of each iteration, indexed by iteration,</li><li><code>:number_waitingworkers</code>: array of number of wainting workers, indexed by iteration,</li><li><code>:maxdelay</code>: array of maximal delay among done workers, indexed by iteration,</li><li><code>:dist_opt</code>: if dict has entry <code>:approxsol</code>, array of distance between iterate and <code>hist[:approxsol]</code>, indexed by iteration.</li><li><code>:logstep</code>: number of iteration between each log.</li></ul></li><li><code>optimizer</code>: an optimizer for subproblem solve.</li><li><code>optimizer_params</code>: a <code>Dict{Symbol, Any}</code> storing parameters for the optimizer.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/yassine-laguel/RPH.jl/blob/038e6096a58fcd9beb0d08cf22d5f83c2512c436/src/solve_randomized_async.jl#L157-L183">source</a></section><h2><a class="nav-anchor" id="Other-1" href="#Other-1">Other</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.objective_value" href="#JuMP.objective_value"><code>JuMP.objective_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">objective_value(pb, x)</code></pre><p>Evaluate the objective of problem <code>pb</code> at point <code>x</code>.</p><p><strong>Note</strong>: This function discards all subproblem constraints not explicitly returned by the <a href="#RPH.build_fs!"><code>build_fs!</code></a> function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/yassine-laguel/RPH.jl/blob/038e6096a58fcd9beb0d08cf22d5f83c2512c436/src/Problem.jl#L21-L27">source</a><div><div><pre><code class="language-none">objective_value(pb, x, id_scen)</code></pre><p>Evaluate the objective of the subproblem associated with scenario <code>id_scen</code> of problem <code>pb</code> at point <code>x</code>.</p><p><strong>Note</strong>: This function discards all subproblem constraints not explicitly returned by the <a href="#RPH.build_fs!"><code>build_fs!</code></a> function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/yassine-laguel/RPH.jl/blob/038e6096a58fcd9beb0d08cf22d5f83c2512c436/src/Problem.jl#L39-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RPH.cvar_problem-Tuple{Problem,CVar}" href="#RPH.cvar_problem-Tuple{Problem,CVar}"><code>RPH.cvar_problem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pb_cvar = cvar_problem(pb::Problem, cvar::CVar)</code></pre><p>Build the problem with risk measure corresponding to <code>cvar</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/yassine-laguel/RPH.jl/blob/038e6096a58fcd9beb0d08cf22d5f83c2512c436/src/riskmeasures.jl#L3-L7">source</a></section><footer><hr/><a class="previous" href="../quickstart/"><span class="direction">Previous</span><span class="title">Tutorial</span></a><a class="next" href="../internal_api/"><span class="direction">Next</span><span class="title">Internal</span></a></footer></article></body></html>
